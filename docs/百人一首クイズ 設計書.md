# 百人一首クイズ 設計書

## 1. はじめに

### 1.1. 目的
- 本ドキュメントは、要件定義書で定められた「百人一首クイズ」アプリケーションを、Python および Streamlit を用いて開発するための具体的な設計を定めることを目的とします。

### 1.2. 開発環境・使用技術
- 言語: Python 3.9 以降
- フレームワーク: Streamlit 1.25 以降
- データ形式: JSON

## 2. システム構成

- 本アプリケーションは、Streamlitサーバー上で動作する単一のPythonスクリプトで構成されます。
- hyakunin_isshu.jsonファイルを読み込み、ユーザーとのインタラクションはすべてWebブラウザを通じて行われます。

``` Python
graph TD
    subgraph "サーバー"
        A[main.py (Streamlitアプリ)] -- 読み込み --> B[hyakunin_isshu.json];
    end
    A <--> C[ユーザーのブラウザ];
```

## 3. 画面設計 (UI設計)

- Streamlitのウィジェットを用いて、シンプルで直感的なUIを構築します。
- 画面は単一ページで構成され、ユーザーのアクションに応じて動的に表示が切り替わります。

### 3.1. 画面レイアウト

|エリア	|コンポーネント	|説明	|
|:-	|:-	|:-	|
|ヘッダー	|st.title	|アプリケーションのタイトルを表示します。|		
|設定エリア	|st.sidebar.radio("出題順", ...)|サイドバーで「ID順」または「ランダム」の出題順を選択させます。|		
|問題表示	|t.header(f"第{問}問")	|現在の問題番号を表示します。|	
|	|st.subheader(上の句)	|問題文である上の句を大きく表示します。|		
|回答エリア	|st.radio("下の句を選んでください", ...)	|4択の下の句を選択肢として表示します。回答後は無効化します。|		
操作エリア	|st.button("回答")	|回答を決定するためのボタン。回答後に非表示または無効化します。|		
|	|st.button("次の問題へ")	|次の問題に進むためのボタン。回答後に表示されます。|		
|結果表示	|st.success("正解！") or st.error("不正解...")	|正誤判定の結果を色付きのアラートで表示します。	|	
|解説表示	|st.info(解説文)	|該当する歌の解説を情報ボックスで表示します。|		

### 3.2. 画面遷移イメージ

#### 初期/問題表示画面: 
- タイトル、問題番号、上の句、選択肢、そして「回答」ボタンが表示される。

#### 回答後画面: 
- 選択肢がハイライトされ、正誤メッセージと解説が表示される。「回答」ボタンが無効化され、「次の問題へ」ボタンが有効化される。 


## 4. 機能設計
- Streamlitの状態管理機能 st.session_state を中心に、各機能を実装します。

### 4.1. データ読み込み機能
- hyakunin_isshu.json を読み込み、リスト形式でデータを保持します。
- Streamlitのキャッシュ機能 @st.cache_data を使用し、アプリのパフォーマンスを向上させます。

#### 実装方針

``` Python
import streamlit as st
import json

@st.cache_data
def load_data(filepath="hyakunin_isshu.json"):
    with open(filepath, "r", encoding="utf-8") as f:
        return json.load(f)
```

### 4.2. クイズ状態管理機能 (st.session_state)
- アプリケーションの状態（現在の問題、スコアなど）をページのリロードをまたいで保持するために st.session_state を使用します。

#### 管理する主なキー:

- **question_list**: 出題順に並んだ歌のIDリスト ([1, 2, ...] or [5, 88, 23, ...])
- **current_question_index**: question_list の現在のインデックス (例: 0, 1, 2...)
- **user_answer**: ユーザーが選択した下の句
- **is_answered**: 回答済みかどうかのフラグ (True/False)
- **score**: 正解数

#### 実装方針:

``` Python
if "current_question_index" not in st.session_state:
    # 初回起動時の初期化処理
    st.session_state.current_question_index = 0
    st.session_state.is_answered = False
    st.session_state.score = 0
    # ... 他の初期化
```

### 4.3. 問題・選択肢生成機能

- 現在の問題番号 (current_question_index) に基づき、問題データを取得します。
- 正解の下の句を1つ、それ以外の歌からランダムに3つの下の句を抽出し、4つの選択肢を作成します。
- random.shuffle() を用いて選択肢の順序をシャッフルします。

### 4.4. 回答・正誤判定機能

- 「回答」ボタンがクリックされた際のコールバック関数、もしくはボタンの戻り値 True をトリガーとします。
- st.radio で選択された値 (st.session_state.user_answer) と、正解の下の句を比較します。
- 判定結果に基づき、st.session_state.is_answered を True に設定し、正解であれば st.session_state.score をインクリメントします

### 4.5. 次の問題へ進む機能

- 「次の問題へ」ボタンがクリックされた際の処理を定義します。
- st.session_state.current_question_index をインクリメントします。
- st.session_state.is_answered を False に戻します。
- st.experimental_rerun() を呼び出し、画面を再描画して次の問題を表示します。

## 5. データ構造設計

### st.session_state の詳細設計

``` Python
{
    # クイズ全体の状態
    "mode": "ID順" or "ランダム",  # クイズのモード
    "question_list": [int],       # 出題IDのリスト
    "all_poems": [dict],          # hyakunin_isshu.jsonの全データ

    # 各問題の状態
    "current_question_index": int, # 現在の問題のインデックス
    "current_poem": dict,         # 現在の問題の歌データ
    "options": [str],             # 現在の4つの選択肢（下の句）
    "correct_answer": str,        # 現在の正解の下の句

    # ユーザーアクションと結果
    "user_answer": str,           # ユーザーが選択した選択肢
    "is_answered": bool,          # 回答済みかどうかのフラグ
    "score": int,                 # 現在の正解数
}
```

## 6. 実装サンプル（主要ロジック）

``` Python
import streamlit as st
import json
import random

# --- データ読み込み ---
@st.cache_data
def load_data(filepath="hyakunin_isshu.json"):
    with open(filepath, "r", encoding="utf-8") as f:
        return json.load(f)

# --- 初期化 ---
def initialize():
    poems = load_data()
    st.session_state.all_poems = poems
    
    if "mode" not in st.session_state:
        st.session_state.mode = "ID順"

    # モードに応じて問題リストを作成
    ids = [p["id"] for p in poems]
    if st.session_state.mode == "ランダム":
        random.shuffle(ids)
    st.session_state.question_list = ids

    # その他の状態を初期化
    st.session_state.current_question_index = 0
    st.session_state.score = 0
    st.session_state.is_answered = False

# --- メイン処理 ---
st.title("百人一首クイズ")

# サイドバーでモード選択
mode = st.sidebar.radio("出題順を選択", ("ID順", "ランダム"), key="mode_selector")
if "mode" not in st.session_state or st.session_state.mode != mode:
    st.session_state.mode = mode
    initialize() # モードが変更されたら初期化

# 初期化がまだなら実行
if "all_poems" not in st.session_state:
    initialize()

# --- 問題の準備 ---
q_index = st.session_state.current_question_index
if q_index < len(st.session_state.question_list):
    q_id = st.session_state.question_list[q_index]
    current_poem = next((p for p in st.session_state.all_poems if p["id"] == q_id), None)
    
    # 選択肢の生成（初回のみ）
    if "options" not in st.session_state or st.session_state.is_answered == False:
        correct_lower = current_poem["lower"]
        all_lowers = [p["lower"] for p in st.session_state.all_poems]
        all_lowers.remove(correct_lower)
        wrong_options = random.sample(all_lowers, 3)
        options = wrong_options + [correct_lower]
        random.shuffle(options)
        st.session_state.options = options
        st.session_state.correct_answer = correct_lower

    # --- 画面表示 ---
    st.header(f"第 {q_index + 1} 問")
    st.subheader(current_poem["upper"])
    
    user_answer = st.radio(
        "下の句を選んでください",
        st.session_state.options,
        key=f"q_{q_id}",
        disabled=st.session_state.is_answered
    )

    # --- ボタン処理 ---
    if not st.session_state.is_answered:
        if st.button("回答"):
            st.session_state.is_answered = True
            if user_answer == st.session_state.correct_answer:
                st.session_state.score += 1
                st.success("正解！")
            else:
                st.error(f"不正解... 正解は「{st.session_state.correct_answer}」でした。")
            
            st.info(f"【解説】\n{current_poem['description']}")
            st.experimental_rerun() # 状態を反映して再描画
    else:
        if st.button("次の問題へ"):
            st.session_state.current_question_index += 1
            st.session_state.is_answered = False
            # `options` をクリアして次の問題で再生成させる
            del st.session_state.options 
            st.experimental_rerun()

else:
    # --- 終了画面 ---
    st.header("クイズ終了！")
    st.balloons()
    st.subheader(f"あなたのスコア: {st.session_state.score} / {len(st.session_state.question_list)}")
    if st.button("もう一度挑戦する"):
        initialize()
        st.experimental_rerun()
```














